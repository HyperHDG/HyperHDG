import configparser, os, sys, importlib, glob, re, datetime


CYTHON_COM  = "cython"
COMPILE_COM = "g++-8"
LINKER_COM  = "g++-8"
PYTHON_DIR  = "/usr/include/python" + str(sys.version_info.major) + "." + str(sys.version_info.minor)









## \package cython_import
# 
#  \brief   Python interface for HyperHDG library.
#
#  This file is the main ingredient to use the HyperHDG library within Python scripts. Its function
#  \c cython_import compiles the necessary components just-in-time and provides the as classes that
#  can be used within Python. To this end, the Cython package is heavily used. 




class hyperhdg_constructor:
  global_loop = ""
  local_solver = ""
  topology = ""
  geometry = ""
  node_descriptor = ""
  cython_replacements = []
  include_files = []
  debug_mode = False
  def is_consistent(self):
    if not (isinstance(self.global_loop, str) and self.global_loop != ""):
      return False
    if not (isinstance(self.local_solver, str) and  self.local_solver != ""):
      return False
    if not (isinstance(self.topology, str) and self.topology != ""):
      return False
    if not (isinstance(self.geometry, str) and self.geometry != ""):
      return False
    if not (isinstance(self.node_descriptor, str) and self.node_descriptor != ""):
      return False
    if not isinstance(self.debug_mode, bool):
      return False
    if not isinstance(self.cython_replacements, list):
      return False
    for entry in self.cython_replacements:
      if not isinstance(entry, str):
        return False
    if not isinstance(self.include_files, list):
      return False
    for entry in self.include_files:
      if not isinstance(entry, str):
        return False
    return True

## \brief   Function to import classes of the HyperHDG package using Cython.
#
#  This function takes a vector / list of at least two strings. The first string refers to the name
#  of the .pyx and .pxd files located in the cython directory. Each of the .pxd files is clearly
#  associated to one and only one C++ file (.hxx or .cxx). The second string refers to the class
#  that is to be imported (and is defined in the C++ file). Further strings might refer to embedded
#  template parameters or other strings that need to be substituted. Thus, if a .pxd file contains
#  the key word \c CyReplace followed by a two digit number (witout space between word and number),
#  it is replace by the \c vector name's number + 2 entry (the first two names have predefined
#  meaning, cf. above).
#
#  Additionally, a vector of filenames can be specified. These filenames refer to files that need
#  to be imported/included to allow the C++ classes to be compilable. For example, if the class
#  AbstractProblem is to be cythonized it receives a Topology, a Geometry, and a Local Solver as
#  template parameters. The files in which the specified Topology, Geometry, and Local Solver are
#  defined need to be available to the compiler and therefore be added in the filelist.
#
#  First, the method checks whether the build and build/cython_files directories are present. If the
#  build directory is not present, the Python program will construct both  needed directories. If 
#  this has beed done, the program compiles the Cythonize.cxx file that does all the work:
#  It takes  a .pyx and a .pxd file and formats them to allow the coupling of Python and C++ code
#  and does also all compilation steps. The file can be started from Python using the hyCythonizer
#  module (which is generated by compilation of Cythonize.cxx).
#
#  Afterwards, the program imports the class indicated by the vector of names and returns this class
#  to the Python script that started the function. By this, the class is also imported to that
#  script.
#
#  \param   names       Vector containing names of class to be imported.
#  \param   filenames   Vector containing names of files that need to be included. Default is empty.
#  \param   debug_mode  Compile library in debub mode (not in release mode). Default is False.
#  \retval  class       The C++ class (not class member) to be used in the Python code.
#
#  \authors   Guido Kanschat, Heidelberg University, 2020.
#  \authors   Andreas Rupp, Heidelberg University, 2020.
def cython_import(constructor):
  start_time = datetime.datetime.now()
  # Check that constructor is appropriatelly filled.
  assert isinstance(constructor, hyperhdg_constructor) and constructor.is_consistent()

  # Start program.
  print("Cythonizing ... ", end='', flush=True)

  # Create folders and log files and check for consistency.
  os.system("mkdir -p " + main_path() + "/build " + main_path() + "/build/cython_files " \
            + main_path() + "/build/shared_objects output")
  if not os.path.isfile(main_path() + "/build/cython_log.txt"):
    file = open(main_path() + "/build/cython_log.txt", "w")
    file.write("Python version: " + str(sys.version_info))
    file.close()
  else:
    file = open(main_path() + "/build/cython_log.txt", "r")
    assert file.readline() == "Python version: " + str(sys.version_info), \
           "Wrong Python version!\n \
            Remove build directory and reinstall HyperHDG or use previous Python version."
    file.close()

  # Evaluate configfile, define include files, and define dependent files.
  cy_replace      = evaluate_config(constructor)
  include_string  = extract_includes(constructor)
  cpp_class, python_class, cython_class = file_names(constructor)

  compilation_necessary = need_compile(constructor, python_class)
  if compilation_necessary:
    # Copy pyx and pxd files from cython directory.
    for file_end in ["pxd", "pyx"]:
      with open(main_path()+"/cython/"+constructor.global_loop.lower()+"."+file_end, "r") as file:
        content = file.read()
    content = re.sub("C\+\+ClassName", "\"" + cpp_class + "\"", content)
    content = re.sub("CythonClassName", cython_class, content)
    content = re.sub("PythonClassName", python_class, content)
    content = re.sub("IncludeFiles", include_string, content)
    for i in range(len(cy_replace)):
      content = re.sub("CyReplace" + '%02d' % (i+1), cy_replace[i], content)
    with open(main_path() + "/build/cython_files/" + python_class + "." + file_end, "w") as file:
      file.write(content)
    # Prepare the compilation commands.
    cython_command, compile_command, link_command = get_commands(python_class)
    if not (constructor.debug_mode):
      compile_command = compile_command + " -DNDEBUG";
    #Actually compile the prepared files.
    os.system(cython_command);
    os.system(compile_command);
    os.system(link_command);

  try:
    mod = importlib.import_module(python_class)
  except ImportError as error:
    sys.path.append(main_path() + "/build/shared_objects")
    mod = importlib.import_module(python_class)

  delta_time_ms = 1000 * (datetime.datetime.now() - start_time).total_seconds()
  if compilation_necessary:
    print("DONE with compilation in " + "{:.2f}".format(delta_time_ms) + " milliseconds.")
  else:
    print("DONE without compilation in " + "{:.2f}".format(delta_time_ms) + " milliseconds.")

  return getattr(mod, python_class)


def extract_classname(fullname):
  index = fullname.find('<')
  return fullname[0:index if index != -1 else len(fullname)]

def find_definition(folder, classname):
  for file in glob.glob(main_path() + "/include/HyperHDG/" + folder + "/*.hxx"):
    with open(file, "r") as hxxfile:
      if ("class " + classname or "struct " + classname) in hxxfile.read():
        return re.sub(main_path() + "/include/", '', file)
  assert False, "File containing defintion of " + classname + " has not been found!"

def evaluate_config(constructor):
  config = configparser.ConfigParser()
  config.read(main_path() + "/cython/" + constructor.global_loop.lower() + ".cfg")
  n_replacements = int(config['default']['n_replacements'])
  cy_replace = []
  for i in range(n_replacements):
    if i < len(constructor.cython_replacements) and constructor.cython_replacements[i] != "":
      cy_replace.append(constructor.cython_replacements[i])
    else:
      assert config.has_option('default','replacement' + '%02d' % (i+1))
      cy_replace.append(config['default']['replacement' + '%02d' % (i+1)])
  assert n_replacements == len(cy_replace)
  return cy_replace

def extract_includes(constructor):
  constructor.include_files.append(find_definition(
    "global_loop", extract_classname(constructor.global_loop)))
  constructor.include_files.append(find_definition(
    "local_solver", extract_classname(constructor.local_solver)))
  constructor.include_files.append(find_definition(
    "topology", extract_classname(constructor.topology)))
  constructor.include_files.append(find_definition(
    "geometry", extract_classname(constructor.geometry)))
  constructor.include_files.append(find_definition(
    "node_descriptor", extract_classname(constructor.node_descriptor)))
  constructor.include_files = list(set(constructor.include_files))
  include_string = ""
  for x in constructor.include_files:
    include_string = include_string + "cdef extern from \"<" + x + ">\": pass\n"
  return include_string

def file_names(constructor):
  cpp_class    = "GlobalLoop::" + constructor.global_loop + "<Topology::" + constructor.topology \
                 + ",Geometry::" + constructor.geometry + ",NodeDescriptor::" \
                 + constructor.node_descriptor + ",LocalSolver::" + constructor.local_solver + " >"
  cython_file  = cpp_class + "_deb" if constructor.debug_mode else cpp_class + "_rel"
  cython_file  = re.sub(' ', '', cython_file)
  cython_file  = re.sub('\+|\-|\*|\/|<|>|\,|\:', '_', cython_file)
  cython_class = cython_file + "CP"
  return cpp_class, cython_file, cython_class

def get_commands(python_class):
  cython_command = "cd " + main_path() + "/build/cython_files/; " + CYTHON_COM + " -3 --cplus " \
    + python_class + ".pyx";
  compile_command = "cd " + main_path() + "; " + COMPILE_COM + " -pthread -g -I. -Iinclude -I" \
    + PYTHON_DIR +" -Isubmodules/tensor_product_chain_complex.git/include -fwrapv -O2 -Wall -g \
    -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 \
    -fPIC --std=c++17 -c ./build/cython_files/" + python_class + ".cpp -o ./build/cython_files/" \
    + python_class + ".o";
  link_command = "cd " + main_path() + "; " + LINKER_COM + " -pthread -shared -Wl,-O1 \
    -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-Bsymbolic-functions \
    -Wl,-z,relro -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time \
    -D_FORTIFY_SOURCE=2 ./build/cython_files/" + python_class + ".o " + "-o build/shared_objects/" \
    + python_class + ".so -llapack -lstdc++fs";
  return cython_command, compile_command, link_command

def need_compile(constructor, python_class):
  if not os.path.isfile(main_path() + "/build/shared_objects/" + python_class + ".so"):
    return True
  time_so = os.stat(main_path() + "/build/shared_objects/" + python_class + ".so").st_mtime
  return True

def main_path():
  return os.path.dirname(os.path.abspath(__file__))