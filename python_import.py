import configparser, os, sys, importlib, glob, re

## \package cython_import
# 
#  \brief   Python interface for HyperHDG library.
#
#  This file is the main ingredient to use the HyperHDG library within Python scripts. Its function
#  \c cython_import compiles the necessary components just-in-time and provides the as classes that
#  can be used within Python. To this end, the Cython package is heavily used. 

def extract_classname(fullname):
  index = fullname.find('<')
  if index == -1:
    return fullname
  else:
    return fullname[0:index]


def find_definition(folder, classname):
  for file in glob.glob(os.getcwd() + "/include/HyperHDG/" + folder + "/*.hxx"):
    with open(file, "r") as hxxfile:
      if "class " + classname in hxxfile.read() or "struct " + classname in hxxfile.read():
        return re.sub(os.getcwd() + "/include/", '', file)
  assert False, "File containing defintion of " + classname + " has not been found!"


class hyperhdg_constructor:
  global_loop = ""
  local_solver = ""
  topology = ""
  geometry = ""
  node_descriptor = ""
  cython_replacements = []
  include_files = []
  debug_mode = False
  def is_consistent(self):
    if not (isinstance(self.global_loop, str) and self.global_loop != ""):
      return False
    if not (isinstance(self.local_solver, str) and  self.local_solver != ""):
      return False
    if not (isinstance(self.topology, str) and self.topology != ""):
      return False
    if not (isinstance(self.geometry, str) and self.geometry != ""):
      return False
    if not (isinstance(self.node_descriptor, str) and self.node_descriptor != ""):
      return False
    if not isinstance(self.debug_mode, bool):
      return False
    if not isinstance(self.cython_replacements, list):
      return False
    for entry in self.cython_replacements:
      if not isinstance(entry, str):
        return False
    if not isinstance(self.include_files, list):
      return False
    for entry in self.include_files:
      if not isinstance(entry, str):
        return False
    return True

## \brief   Function to import classes of the HyperHDG package using Cython.
#
#  This function takes a vector / list of at least two strings. The first string refers to the name
#  of the .pyx and .pxd files located in the cython directory. Each of the .pxd files is clearly
#  associated to one and only one C++ file (.hxx or .cxx). The second string refers to the class
#  that is to be imported (and is defined in the C++ file). Further strings might refer to embedded
#  template parameters or other strings that need to be substituted. Thus, if a .pxd file contains
#  the key word \c CyReplace followed by a two digit number (witout space between word and number),
#  it is replace by the \c vector name's number + 2 entry (the first two names have predefined
#  meaning, cf. above).
#
#  Additionally, a vector of filenames can be specified. These filenames refer to files that need
#  to be imported/included to allow the C++ classes to be compilable. For example, if the class
#  AbstractProblem is to be cythonized it receives a Topology, a Geometry, and a Local Solver as
#  template parameters. The files in which the specified Topology, Geometry, and Local Solver are
#  defined need to be available to the compiler and therefore be added in the filelist.
#
#  First, the method checks whether the build and build/cython_files directories are present. If the
#  build directory is not present, the Python program will construct both  needed directories. If 
#  this has beed done, the program compiles the Cythonize.cxx file that does all the work:
#  It takes  a .pyx and a .pxd file and formats them to allow the coupling of Python and C++ code
#  and does also all compilation steps. The file can be started from Python using the hyCythonizer
#  module (which is generated by compilation of Cythonize.cxx).
#
#  Afterwards, the program imports the class indicated by the vector of names and returns this class
#  to the Python script that started the function. By this, the class is also imported to that
#  script.
#
#  \param   names       Vector containing names of class to be imported.
#  \param   filenames   Vector containing names of files that need to be included. Default is empty.
#  \param   debug_mode  Compile library in debub mode (not in release mode). Default is False.
#  \retval  class       The C++ class (not class member) to be used in the Python code.
#
#  \authors   Guido Kanschat, Heidelberg University, 2020.
#  \authors   Andreas Rupp, Heidelberg University, 2020.
def cython_import(constructor):
  # Check that constructor is appropriatelly filled.
  assert isinstance(constructor, hyperhdg_constructor) and constructor.is_consistent()

  # Create folders and log files and check for consistency.
  os.system("mkdir -p build build/cython_files build/shared_objects output")
  if not os.path.isfile("build/cython_log.txt"):
    file = open(os.getcwd() + "/build/cython_log.txt", "w")
    file.write("Python version: " + str(sys.version_info))
    file.close()
  else:
    file = open(os.getcwd() + "/build/cython_log.txt", "r")
    assert file.readline() == "Python version: " + str(sys.version_info), \
           "Wrong Python version!\n \
            Remove build directory and reinstall HyperHDG or use previous Python version."
    file.close()

  # Evaluate configfile.
  config = configparser.ConfigParser()
  config.read(os.getcwd() + "/cython/" + constructor.global_loop.lower() + ".cfg")
  n_replacements = int(config['default']['n_replacements'])
  cy_rep = []
  for i in range(n_replacements):
    if i < len(constructor.cython_replacements) and constructor.cython_replacements[i] != "":
      cy_rep.append(constructor.cython_replacements[i])
    else:
      assert config.has_option('default','replacement' + '%02d' % (i+1))
      cy_rep.append(config['default']['replacement' + '%02d' % (i+1)])

  # Find files in which class instances are defined and remove duplicates.
  constructor.include_files.append(find_definition(
    "global_loop", extract_classname(constructor.global_loop)))
  constructor.include_files.append(find_definition(
    "local_solver", extract_classname(constructor.local_solver)))
  constructor.include_files.append(find_definition(
    "topology", extract_classname(constructor.topology)))
  constructor.include_files.append(find_definition(
    "geometry", extract_classname(constructor.geometry)))
  constructor.include_files.append(find_definition(
    "node_descriptor", extract_classname(constructor.node_descriptor)))
  constructor.include_files = list(set(constructor.include_files))
  include_files = ""
  for x in constructor.include_files:
    include_files = include_files + "include <" + x + ">\n"

  # Define Python and Cython names.

  # Copy pyx and pxd files from cython directory.
  file = open(os.getcwd() + "/cython/" + constructor.global_loop.lower() + ".pxd", "r")
  content = file.read()
  file.close()
  content = re.sub("IncludeFiles", include_files, content)
  for i in range(n_replacements):
    content = re.sub("CyReplace" + '%02d' % (i+1), cy_rep[i], content)
  file =open(os.getcwd() + "/build/cython_files/" + constructor.global_loop.lower() + ".pxd", "w")
  file.write(content)
  file.close()
  file = open(os.getcwd() + "/cython/" + constructor.global_loop.lower() + ".pyx", "r")
  content = file.read()
  file.close()
  content = re.sub("IncludeFiles", include_files, content)
  for i in range(n_replacements):
    content = re.sub("CyReplace" + '%02d' % (i+1), cy_rep[i], content)
  file =open(os.getcwd() + "/build/cython_files/" + constructor.global_loop.lower() + ".pyx", "w")
  file.write(content)
  file.close()


  cythonCommand = "cd ./build/cython_files/; cython -3 --cplus " + python_name + ".pyx";
  compileCommand = \
    "g++ -pthread -g -I. -Iinclude -I/usr/include/python" + pyVersion +
    " -Isubmodules/tensor_product_chain_complex.git/include -fwrapv -O2 -Wall -g \
    -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 \
    -fPIC --std=c++17 -c " + outfileName + ".cpp -o " + outfileName + ".o";
  if (!debug_mode)
   compileCommand.append(" -DNDEBUG");
  linkCommand =
    "g++ -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro \
    -Wl,-Bsymbolic-functions -Wl,-z,relro -g -fstack-protector-strong -Wformat \
    -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 " +
    outfileName + ".o " + "-o build/shared_objects/" + python_name + ".so -llapack -lstdc++fs";

  print(constructor.include_files)